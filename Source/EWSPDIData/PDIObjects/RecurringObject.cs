//===============================================================================================================
// System  : Personal Data Interchange Classes
// File    : RecurringObject.cs
// Author  : Eric Woodruff  (Eric@EWoodruff.us)
// Updated : 01/02/2025
// Note    : Copyright 2004-2025, Eric Woodruff, All rights reserved
//
// This file contains an abstract base class from which recurring calendar objects are derived.  It defines a
// common set of properties and methods used to resolve an object to one or more dates based on the combination
// of recurrence rules, recurrence dates, exception rules, and exception dates.
//
// This code is published under the Microsoft Public License (Ms-PL).  A copy of the license should be
// distributed with the code and can be found at the project website: https://github.com/EWSoftware/PDI.
// This notice, the author's name, and all copyright notices must remain intact in all applications,
// documentation, and source files.
//
//    Date     Who  Comments
// ==============================================================================================================
// 03/28/2004  EFW  Created the code
// 09/02/2007  EFW  Added code to correct for DST duplicate entries
//===============================================================================================================

using System;
using System.IO;
using System.Linq;
using System.Text;

using EWSoftware.PDI.Properties;

namespace EWSoftware.PDI.Objects
{
    /// <summary>
    /// This is an abstract base class from which recurring calendar objects are derived.  It defines a common
    /// set of properties and methods used to resolve an object to one or more dates based on the combination of
    /// recurrence rules, recurrence dates, exception rules, and exception dates.
    /// </summary>
    public abstract class RecurringObject : CalendarObject
    {
        #region Private data members
        //=====================================================================

        private RRulePropertyCollection  rRules = null!, exRules = null!;
        private RDatePropertyCollection rDates = null!;
        private ExDatePropertyCollection exDates = null!;

        #endregion

        #region Properties
        //=====================================================================

        /// <summary>
        /// This property can be used to override the specification and exclude the start date/time if it is not
        /// generated by one of the recurrence rule or recurrence date properties.
        /// </summary>
        /// <value><para>By default, the start date/time of a calendar object is always included in the set of
        /// date/times even if it does not match one generated by a recurrence rule or recurrence date property.
        /// Normally, you must exclude it using an exception date or an exception rule.  If you would prefer to
        /// exclude the starting date/time unless it is generated by a recurrence rule or date without using an
        /// exception, set this property to true.</para>
        /// 
        /// <para>This property is saved as a custom property when written to a PDI data stream
        /// (<c>X-EWSOFTWARE-EXCLUDESTART:1</c>).  Also be /// aware that it is not compatible with other
        /// calendaring systems.</para></value>
        public bool ExcludeStartDateTime { get; set; }

        /// <summary>
        /// This is used to get the Recurrence Rule (RRULE) properties.  There may be more than one.
        /// </summary>
        /// <value>If the returned collection is empty, there are no recurrence rule properties for the object</value>
        public RRulePropertyCollection RecurrenceRules
        {
            get
            {
                rRules ??= [];

                return rRules;
            }
        }

        /// <summary>
        /// This is used to get the Exception Rule (EXRULE) properties.  There may be more than one.
        /// </summary>
        /// <value>If the returned collection is empty, there are no exception rule properties for the object</value>
        public RRulePropertyCollection ExceptionRules
        {
            get
            {
                exRules ??= [];

                return exRules;
            }
        }

        /// <summary>
        /// This is used to get the Recur Date (RDATE) properties.  There may be more than one.
        /// </summary>
        /// <value>If the returned collection is empty, there are no recur date properties for the object.</value>
        public RDatePropertyCollection RecurDates
        {
            get
            {
                rDates ??= [];

                return rDates;
            }
        }

        /// <summary>
        /// This is used to get the Exception Date (EXDATE) properties.  There may be more than one.
        /// </summary>
        /// <value>If the returned collection is empty, there are no exception date properties for the object</value>
        public ExDatePropertyCollection ExceptionDates
        {
            get
            {
                exDates ??= [];

                return exDates;
            }
        }

        /// <summary>
        /// This can be used to see if an item has recurrence information
        /// </summary>
        /// <value>It returns true if any recurrence rules, exception rules, recurrence dates, or exception dates
        /// are defined.  It returns false if none of those items have been specified.</value>
        public bool IsRecurring => this.RecurrenceRules.Count != 0 || this.ExceptionRules.Count != 0 ||
            this.RecurDates.Count != 0 || this.ExceptionDates.Count != 0;

        /// <summary>
        /// This must be implemented to return the start date/time property that is used to determine when the
        /// first instance occurs.
        /// </summary>
        public abstract StartDateProperty StartDateTime
        {
            get;
        }

        /// <summary>
        /// This must be implemented to return the duration for the recurring instances
        /// </summary>
        public abstract Duration InstanceDuration
        {
            get;
        }

        /// <summary>
        /// This must be implemented to return the time zone ID for the start date
        /// </summary>
        public abstract string? TimeZoneId
        {
            get;
        }
        #endregion

        #region Methods
        //=====================================================================

        /// <summary>
        /// This is overridden to allow copying of the additional properties
        /// </summary>
        /// <param name="p">The PDI object from which the settings are to be copied.</param>
        protected override void Clone(PDIObject p)
        {
            RecurringObject o = (RecurringObject)p;

            this.RecurrenceRules.CloneRange(o.RecurrenceRules);
            this.RecurDates.CloneRange(o.RecurDates);
            this.ExceptionRules.CloneRange(o.ExceptionRules);
            this.ExceptionDates.CloneRange(o.ExceptionDates);
        }

        /// <summary>
        /// The method can be called to clear all current property values from the object.  The version is left
        /// unchanged.
        /// </summary>
        public override void ClearProperties()
        {
            this.RecurrenceRules.Clear();
            this.RecurDates.Clear();
            this.ExceptionRules.Clear();
            this.ExceptionDates.Clear();
        }

        /// <summary>
        /// This is used to propagate the version to all properties in the object that need it
        /// </summary>
        public override void PropagateVersion()
        {
            this.RecurrenceRules.PropagateVersion(this.Version);
            this.RecurDates.PropagateVersion(this.Version);
            this.ExceptionRules.PropagateVersion(this.Version);
            this.ExceptionDates.PropagateVersion(this.Version);
        }

        /// <summary>
        /// This is used to get a list of time zones used by all owned objects
        /// </summary>
        /// <param name="timeZoneIds">A <see cref="StringCollection"/> that will be used to store the list of
        /// unique time zone IDs used by the calendar objects.</param>
        public override void TimeZonesUsed(StringCollection timeZoneIds)
        {
            string? timeZoneId;

            if(rDates != null)
            {
                foreach(RDateProperty rdt in rDates)
                {
                    if(rdt.ValueLocation == ValLocValue.DateTime && rdt.TimeZoneDateTime != DateTime.MinValue)
                    {
                        timeZoneId = rdt.TimeZoneId;

                        if(timeZoneId != null && !timeZoneIds.Contains(timeZoneId))
                            timeZoneIds.Add(timeZoneId);
                    }
                }
            }

            if(exDates != null)
            {
                foreach(ExDateProperty edt in exDates)
                    AddTimeZoneIfUsed(edt, timeZoneIds);
            }
        }

        /// <summary>
        /// This is used to replace an old time zone ID with a new time zone ID in all properties of a calendar
        /// object.
        /// </summary>
        /// <param name="oldId">The old ID being replaced</param>
        /// <param name="newId">The new ID to use</param>
        public override void UpdateTimeZoneId(string? oldId, string? newId)
        {
            if(rDates != null)
            {
                foreach(RDateProperty rdt in rDates)
                {
                    if(rdt.TimeZoneId == oldId)
                        rdt.TimeZoneId = newId;
                }
            }

            if(exDates != null)
            {
                foreach(ExDateProperty edt in exDates)
                    UpdatePropertyTimeZoneId(edt, oldId, newId);
            }
        }

        /// <summary>
        /// This is used to apply the selected time zone to all date/time objects in the component and convert
        /// them to the new time zone.
        /// </summary>
        /// <param name="vTimeZone">A <see cref="VTimeZone"/> object that will be used for all date/time objects
        /// in the component.</param>
        /// <remarks>When applied, all date/time values in the object will be converted to the new time zone</remarks>
        public override void ApplyTimeZone(VTimeZone? vTimeZone)
        {
            if(rDates != null)
            {
                foreach(RDateProperty rdt in rDates)
                {
                    if(vTimeZone == null || rdt.TimeZoneId != vTimeZone.TimeZoneId.Value)
                    {
                        // If the time zone is null, just clear the time zone ID
                        if(vTimeZone == null)
                            rdt.TimeZoneId = null;
                        else
                        {
                            DateTimeInstance dti = VCalendar.TimeZoneToTimeZone(rdt.TimeZoneDateTime,
                                rdt.TimeZoneId, vTimeZone.TimeZoneId.Value);

                            rdt.TimeZoneDateTime = dti.StartDateTime;
                            rdt.TimeZoneId = vTimeZone.TimeZoneId.Value;
                        }
                    }
                }
            }

            if(exDates != null)
            {
                foreach(ExDateProperty edt in exDates)
                    ApplyPropertyTimeZone(edt, vTimeZone);
            }
        }

        /// <summary>
        /// This is used to set the selected time zone in all date/time objects in the component without
        /// modifying the date/time values.
        /// </summary>
        /// <param name="vTimeZone">A <see cref="VTimeZone"/> object that will be used for all date/time objects
        /// in the component.</param>
        /// <remarks>This method does not affect the date/time values</remarks>
        public override void SetTimeZone(VTimeZone? vTimeZone)
        {
            if(rDates != null)
            {
                foreach(RDateProperty rdt in rDates)
                {
                    if(vTimeZone == null || rdt.TimeZoneId != vTimeZone.TimeZoneId.Value)
                    {
                        // If the time zone is null, just clear the time zone ID
                        if(vTimeZone == null)
                            rdt.TimeZoneId = null;
                        else
                            rdt.TimeZoneId = vTimeZone.TimeZoneId.Value;
                    }
                }
            }

            if(exDates != null)
            {
                foreach(ExDateProperty edt in exDates)
                    SetPropertyTimeZone(edt, vTimeZone);
            }
        }

        /// <summary>
        /// This is used to write recurrence properties to a PDI data stream
        /// </summary>
        /// <param name="tw">A <see cref="System.IO.TextWriter"/> derived class to which the event is written.</param>
        /// <param name="sb">A <see cref="System.Text.StringBuilder"/> used by the properties as a temporary
        /// buffer.  This can be null if the TextWriter is a <see cref="System.IO.StringWriter"/>.</param>
        /// <remarks>This is called by <see cref="CalendarObject.ToString"/> as well as owning objects when they
        /// convert themselves to a string or write themselves to a PDI data stream.</remarks>
        public override void WriteToStream(TextWriter tw, StringBuilder? sb)
        {
            if(rRules != null && rRules.Count != 0)
            {
                foreach(RRuleProperty r in rRules)
                    BaseProperty.WriteToStream(r, sb, tw);
            }

            if(rDates != null && rDates.Count != 0)
            {
                foreach(RDateProperty r in rDates)
                    BaseProperty.WriteToStream(r, sb, tw);
            }

            if(exRules != null && exRules.Count != 0)
            {
                foreach(ExRuleProperty e in exRules.Cast<ExRuleProperty>())
                    BaseProperty.WriteToStream(e, sb, tw);
            }

            if(exDates != null && exDates.Count != 0)
            {
                foreach(ExDateProperty e in exDates)
                    BaseProperty.WriteToStream(e, sb, tw);
            }

            if(this.ExcludeStartDateTime)
                tw.Write("X-EWSOFTWARE-EXCLUDESTART:1\r\n");
        }

        /// <summary>
        /// This method can be used to quickly determine the end date of an item regardless of whether it uses
        /// recurrence or not.
        /// </summary>
        /// <param name="inLocalTime">If true, the date/time is returned expressed in local time.  If false, it
        /// is returned expressed in the time zone of the object as specified by the <see cref="TimeZoneId"/>
        /// property.  If no time zone ID has been specified or it cannot be found, local time is used.</param>
        /// <returns>For non-recurring items, it returns the starting date plus the duration.  For recurring
        /// items, it scans the recurrence rules' <see cref="PDI.Recurrence.RecurUntil"/> property values and the
        /// recurrence dates' <see cref="RDateProperty.DateTimeValue"/> or it's <see cref="RDateProperty.PeriodValue"/>'s
        /// <see cref="PDI.Period.EndDateTime"/> property values to find the highest date/time and returns that
        /// plus the duration.  Note that it will not expand the recurrence rules.  Exception rules and exception
        /// dates are ignored.  This is useful for finding out whether or not an item may generate a date in a
        /// given range without actually expanding it completely.</returns>
        public DateTime LastInstance(bool inLocalTime)
        {
            DateTime endDate, dt = this.StartDateTime.DateTimeValue;
            TimeSpan ts = this.InstanceDuration.TimeSpan;

            if(this.IsRecurring)
            {
                foreach(RRuleProperty r in this.RecurrenceRules)
                    if(r.Recurrence.RecurUntil > dt)
                    {
                        dt = r.Recurrence.RecurUntil;

                        if(dt != DateTime.MaxValue)
                            dt = dt.Add(ts);
                    }

                foreach(RDateProperty rd in this.RecurDates)
                {
                    if(rd.ValueLocation != ValLocValue.Period)
                    {
                        // If it's not a period, use the component's duration.  If it's only a date, assume it's
                        // the whole day.  The spec is not clear on this so I'm making a best guess.
                        if(rd.ValueLocation == ValLocValue.DateTime)
                            endDate = rd.DateTimeValue.Add(ts);
                        else
                            endDate = rd.DateTimeValue.Add(new TimeSpan(TimeSpan.TicksPerDay));
                    }
                    else
                        endDate = rd.PeriodValue.EndDateTime;

                    if(endDate > dt)
                        dt = endDate;
                }
            }
            else
                if(dt != DateTime.MaxValue)
                    dt = dt.Add(ts);

            return inLocalTime ? dt : VCalendar.LocalTimeToTimeZoneTime(dt, this.TimeZoneId).StartDateTime;
        }

        /// <summary>
        /// This method is used to return all recurring instances based on the current settings alone
        /// </summary>
        /// <param name="inLocalTime">If true, the date/times are returned expressed in local time.  If false,
        /// they are returned expressed in the time zone of the object as specified by the <see cref="TimeZoneId"/>
        /// property.  If no time zone ID has been specified or it cannot be found, local time is used.</param>
        /// <returns>Returns a <see cref="DateTimeInstanceCollection"/> containing <see cref="DateTimeInstance" />
        /// objects that represent all instances found using the current settings.  Instances may have a
        /// different duration than that of the component if created from an <c>RDATE</c> property.</returns>
        /// <remarks>This is best used with recurrences that end after a specific number of occurrences or by a
        /// specific date.  If set to never end, this will return a really large collection of instances.</remarks>
        /// <exception cref="ArgumentException">This is thrown if a start date has not been specified (it equals
        /// <c>DateTime.MinValue</c>) or the duration is negative.</exception>
        /// <seealso cref="InstancesBetween"/>
        /// <seealso cref="OccursOn"/>
        public DateTimeInstanceCollection AllInstances(bool inLocalTime)
        {
            // If not in local time, pass InstancesBetween() the time zone time value.
            if(!inLocalTime)
                return InstancesBetween(this.StartDateTime.TimeZoneDateTime, DateTime.MaxValue, false);

            return InstancesBetween(this.StartDateTime.DateTimeValue, DateTime.MaxValue, true);
        }

        /// <summary>
        /// This method is used to determine whether or not an instance of the recurrence falls on the specified
        /// date/time.
        /// </summary>
        /// <param name="checkDate">The date/time to check for an occurrence</param>
        /// <param name="includeTime">If true, time is included in the search.  If false, time is ignored and it
        /// returns true if an instance occurs at any time on the given date.</param>
        /// <param name="inLocalTime">If true, the date/time parameter is assumed to be in local time and the
        /// recurrence date/times are checked in local time.  If false, the date/time parameter is assumed to be
        /// in the time zone of the object and the recurrence date/times are checked in the time zone of the
        /// object as specified by the <see cref="TimeZoneId"/> property.  If no time zone ID has been specified
        /// or it cannot be found, local time is used.</param>
        /// <returns>Returns true if an instance occurs on the specified date/time, false if not</returns>
        /// <exception cref="ArgumentException">This is thrown if a start date has not been specified (it equals
        /// <c>DateTime.MinValue</c>) or the duration is negative.</exception>
        /// <seealso cref="InstancesBetween"/>
        /// <seealso cref="AllInstances"/>
        public bool OccursOn(DateTime checkDate, bool includeTime, bool inLocalTime)
        {
            if(includeTime)
                return (this.InstancesBetween(checkDate, checkDate, inLocalTime).Count != 0);

            // Use the full time range for the given date.  Pass false for inLocalTime as we don't want it
            // converting these to the time zone time.
            return (this.InstancesBetween(checkDate.Date, new DateTime(checkDate.Year, checkDate.Month,
                checkDate.Day, 23, 59, 59), false).Count != 0);
        }

        /// <summary>
        /// This method is used to return all recurring instances between the two specified date/times based on
        /// the current settings.
        /// </summary>
        /// <param name="fromDate">The minimum date/time on or after which instances should occur.  This will
        /// include an instance if it starts before the date/time but overlaps it when its duration is added to
        /// its start time.</param>
        /// <param name="toDate">The maximum date/time on or before which instances should occur.  This will
        /// include an instance if it starts on or before the specified date/time regardless of its duration.</param>
        /// <param name="inLocalTime">If true, the date/time parameters are assumed to be in local time and the
        /// returned date/times are expressed in local time.  If false, the date/time parameters are assumed to
        /// be in the time zone of the object and the returned date/times are expressed in the time zone of the
        /// object as specified by the <see cref="TimeZoneId"/> property.  If no time zone ID has been specified
        /// or it cannot be found, local time is used.</param>
        /// <returns>Returns a <see cref="DateTimeInstanceCollection"/> containing <see cref="DateTimeInstance" />
        /// objects that represent all instances found between the two specified date/times.  Instances may have
        /// a different duration if created from an <c>RDATE</c> property.</returns>
        /// <exception cref="ArgumentException">This is thrown if a start date has not been specified (it equals
        /// <c>DateTime.MinValue</c>) or the duration is negative.</exception>
        /// <seealso cref="AllInstances"/>
        /// <seealso cref="OccursOn"/>
        public DateTimeInstanceCollection InstancesBetween(DateTime fromDate, DateTime toDate, bool inLocalTime)
        {
            DateTimeCollection recurDates;
            Period p;
            DateTime endDate, tempDate1 = DateTime.MaxValue, tempDate2;
            int idx, count;
            string? timeZoneID = this.TimeZoneId;

            PeriodCollection periods = [];
            DateTime startDate = this.StartDateTime.TimeZoneDateTime;
            Duration dur = this.InstanceDuration;

            if(startDate == DateTime.MinValue)
                throw new ArgumentException(LR.GetString("ExNoComponentStartDate"));

            if(dur.Ticks < 0)
                throw new ArgumentException(LR.GetString("ExRONegativeDuration"));

            // Convert fromDate and toDate to time zone time if inLocalTime is true.  Recurrences are always
            // resolved in the time of the object.
            if(inLocalTime && timeZoneID != null)
            {
                fromDate = VCalendar.LocalTimeToTimeZoneTime(fromDate, timeZoneID).StartDateTime;
                toDate = VCalendar.LocalTimeToTimeZoneTime(toDate, timeZoneID).StartDateTime;
            }

            // There might be instances that overlap the requested range so we'll adjust the From date/time by
            // the duration to catch them.
            if(dur.Ticks > 1)
                fromDate = fromDate.Add(new TimeSpan(0 - dur.Ticks + 1));

            // As per the spec, the start date/time is always included in the set but only if it (or it's
            // duration) is within the requested range.  However, if it is recurring and the custom Exclude Start
            // property is set to true, it is not added.
            p = new Period(startDate, dur);

            if(((p.StartDateTime >= fromDate && p.StartDateTime <= toDate) || (p.EndDateTime >= fromDate &&
              p.EndDateTime <= toDate)) && (!this.IsRecurring || !this.ExcludeStartDateTime))
            {
                periods.Add(p);
            }

            // If it isn't recurring or starts after the requested end date, just return the collection as it is
            if(this.IsRecurring && startDate <= toDate)
            {
                // Expand each recurrence rule
                foreach(RRuleProperty rr in this.RecurrenceRules)
                {
                    // If used, RecurUntil is stored in Universal Time which is converted to local time.  If a
                    // time zone ID is specified, convert it to that time zone temporarily to make sure things
                    // are calculated correctly.
                    if(rr.Recurrence.MaximumOccurrences == 0 && timeZoneID != null)
                    {
                        tempDate1 = rr.Recurrence.RecurUntil;
                        rr.Recurrence.RecurUntil = VCalendar.LocalTimeToTimeZoneTime(tempDate1, timeZoneID).StartDateTime;
                    }

                    rr.Recurrence.StartDateTime = startDate;
                    recurDates = rr.Recurrence.InstancesBetween(fromDate, toDate);

                    if(rr.Recurrence.MaximumOccurrences == 0 && timeZoneID != null)
                        rr.Recurrence.RecurUntil = tempDate1;

                    foreach(DateTime dt in recurDates)
                        periods.Add(new Period(dt, dur));
                }

                // Add on recurrence dates within the range
                foreach(RDateProperty rd in this.RecurDates)
                {
                    if(rd.ValueLocation != ValLocValue.Period)
                    {
                        // If it's not a period, use the component's duration.  If it's only a date, assume it's
                        // the whole day.  The spec is not clear on this so I'm making a best guess.
                        if(rd.ValueLocation == ValLocValue.DateTime)
                            endDate = rd.TimeZoneDateTime.Add(dur.TimeSpan);
                        else
                            endDate = rd.TimeZoneDateTime.Add(new TimeSpan(TimeSpan.TicksPerDay));

                        if((rd.TimeZoneDateTime >= fromDate && rd.TimeZoneDateTime <= toDate) ||
                          (endDate >= fromDate && endDate <= toDate))
                        {
                            periods.Add(new Period(rd.TimeZoneDateTime, endDate));
                        }
                    }
                    else
                    {
                        // As with Recurrence.RecurUntil, the period values are in Universal Time so convert them
                        // to the time zone time for proper comparison.
                        tempDate1 = rd.PeriodValue.StartDateTime;
                        tempDate2 = rd.PeriodValue.EndDateTime;

                        if(timeZoneID != null)
                            tempDate1 = VCalendar.LocalTimeToTimeZoneTime(tempDate1, timeZoneID).StartDateTime;

                        if(timeZoneID != null)
                            tempDate2 = VCalendar.LocalTimeToTimeZoneTime(tempDate2, timeZoneID).StartDateTime;

                        if((tempDate1 >= fromDate && tempDate1 <= toDate) ||
                          (tempDate2 >= fromDate && tempDate2 <= toDate))
                        {
                            periods.Add(new Period(tempDate1, tempDate2));
                        }
                    }
                }

                // Expand exception rules and filter out those instances
                count = periods.Count;

                foreach(RRuleProperty er in this.ExceptionRules)
                {
                    // Same as above
                    if(er.Recurrence.MaximumOccurrences == 0 && timeZoneID != null)
                    {
                        tempDate1 = er.Recurrence.RecurUntil;
                        er.Recurrence.RecurUntil = VCalendar.LocalTimeToTimeZoneTime(tempDate1, timeZoneID).StartDateTime;
                    }

                    er.Recurrence.StartDateTime = startDate;
                    recurDates = er.Recurrence.InstancesBetween(fromDate, toDate);

                    if(er.Recurrence.MaximumOccurrences == 0 && timeZoneID != null)
                        er.Recurrence.RecurUntil = tempDate1;

                    foreach(DateTime dt in recurDates)
                    {
                        for(idx = 0; idx < count; idx++)
                        {
                            if(periods[idx].StartDateTime == dt)
                            {
                                periods.RemoveAt(idx);
                                idx--;
                                count--;
                            }
                        }
                    }
                }

                // Filter out any exception dates
                foreach(ExDateProperty ed in this.ExceptionDates)
                {
                    DateTime dt = ed.TimeZoneDateTime;

                    // If it's only a date, assume it's the whole day and remove all instances on that day
                    // regardless of the time.  The spec is not clear on this so I'm making a best guess.
                    if(ed.ValueLocation == ValLocValue.DateTime)
                    {
                        if(dt >= fromDate && dt <= toDate)
                            for(idx = 0; idx < count; idx++)
                                if(periods[idx].StartDateTime == dt)
                                {
                                    periods.RemoveAt(idx);
                                    idx--;
                                    count--;
                                }
                    }
                    else
                    {
                        if(dt >= fromDate.Date && dt <= toDate.Date)
                        {
                            for(idx = 0; idx < count; idx++)
                            {
                                if(periods[idx].StartDateTime.Date == dt)
                                {
                                    periods.RemoveAt(idx);
                                    idx--;
                                    count--;
                                }
                            }
                        }
                    }
                }

                // Sort the periods and remove duplicates
                periods.Sort(true);

                for(idx = 1; idx < count; idx++)
                {
                    if(periods[idx] == periods[idx - 1])
                    {
                        periods.RemoveAt(idx);
                        idx--;
                        count--;
                    }
                }
            }

            // Now convert the periods to DateTimeInstances that include the necessary time zone information
            DateTimeInstanceCollection dtic = [];
            DateTimeInstance dti, dtiEnd;

            // Always in local time if there is no time zone ID
            if(timeZoneID == null)
                inLocalTime = true;

            foreach(Period pd in periods)
            {
                if(inLocalTime)
                {
                    dti = VCalendar.TimeZoneTimeToLocalTime(pd.StartDateTime, timeZoneID);
                    dtiEnd = VCalendar.TimeZoneTimeToLocalTime(pd.EndDateTime, timeZoneID);
                }
                else
                {
                    dti = VCalendar.TimeZoneTimeInfo(pd.StartDateTime, timeZoneID);
                    dtiEnd = VCalendar.TimeZoneTimeInfo(pd.EndDateTime, timeZoneID);
                }

                dti.Duration = pd.Duration;
                dti.EndDateTime = dtiEnd.EndDateTime;
                dti.EndIsDaylightSavingTime = dtiEnd.EndIsDaylightSavingTime;
                dti.EndTimeZoneName = dtiEnd.EndTimeZoneName;

                // If it already contains the entry and it is in DST, bump it forward an hour to account for the
                // time adjustment.  This will happen on hourly, minutely, and secondly recurrence patterns.  By
                // moving duplicates forward an hour, we retain the expected number of occurrences.
                if(!dtic.Contains(dti))
                    dtic.Add(dti);
                else
                {
                    if(dti.StartIsDaylightSavingTime)
                    {
                        dti.StartDateTime = dti.StartDateTime.AddHours(1);
                        dti.EndDateTime = dti.EndDateTime.AddHours(1);
                        dtic.Add(dti);
                    }
                }
            }

            return dtic;     // And finally, we are done
        }
        #endregion
    }
}
